-- The core --

_G._START = computer.uptime()

local flags = ... or {}
flags.init = flags.init or "/sbin/init.lua"
flags.quiet = flags.quiet or false

local _KERNEL_NAME = "Monolith"
local _KERNEL_REVISION = "718ea8a"
local _KERNEL_BUILDER = "ocawesome101@manjaro-pbp"
local _KERNEL_COMPILER = "luacomp 1.2.0"

_G._OSVERSION = string.format("%s revision %s (%s, %s)", _KERNEL_NAME, _KERNEL_REVISION, _KERNEL_BUILDER, _KERNEL_COMPILER)

kernel.logger.log("Starting " .. _OSVERSION)

kernel.info = {
  name          = _KERNEL_NAME,
  revision      = _KERNEL_REVISION,
  builder       = _KERNEL_BUILDER,
  compiler      = _KERNEL_COMPILER
}

if computer.setArchitecture then
  kernel.logger.log("Set architecture to Lua 5.3")
  computer.setArchitecture("Lua 5.3")
end

-- --#include "module/logger.lua"

-- component API metatable allowing component.filesystem, and component.get --

do
  function component.get(addr)
    checkArg(1, addr, "string")
    for ca, ct in component.list() do
      if ca:sub(1, #addr) == addr then
        return ca, ct
      end
    end
    return nil, "no such compoennt"
  end

  function component.isAvailable(name)
    checkArg(1, name, "string")
    local ok, comp = pcall(function()return component[name]end)
    return ok
  end

  local mt = {
    __index = function(tbl, k)
      local addr = component.list(k, true)()
      if not addr then
        error("component of type '" .. k .. "' not found")
      end
      tbl[k] = component.proxy(addr)
      return tbl[k]
    end
  }

  setmetatable(component, mt)
end

-- --#include "module/initfs.lua"

-- users --

do
  kernel.logger.log("initializing user subsystem")
  local cuid = 0

  local u = {}

  u.sha = {}
  u.passwd = {}
  u.psave = function()end

  local sha = u.sha
  local function hex(s)
    local r = ""
    for char in s:gmatch(".") do
      r = r .. string.format("%02x", char:byte())
    end
    return r
  end

  function u.authenticate(uid, password)
    checkArg(1, uid, "number")
    checkArg(2, password, "string")
    kernel.logger.log("kernel: check user ID " .. uid)
    if not u.passwd[uid] then
      kernel.logger.log("UID mismatch, no entry")
      return nil, "no user with UID " .. uid
    end
    return hex(u.sha.sha256(password)) == u.passwd[uid].p, "invalid password"
  end

  function u.login(uid, password)
    local yes, why = u.authenticate(uid, password)
    if not yes then
      return yes, why or "invalid credentials"
    end
    cuid = uid
    return yes
  end

  function u.uid()
    return cuid
  end

  function u.add(password, cansudo)
    checkArg(1, password, "string")
    checkArg(2, cansudo, "boolean", "nil")
    if u.uid() ~= 0 then
      return nil, "only root can do that"
    end
    local nuid = #u.passwd + 1
    u.passwd[nuid] = {p = hex(u.sha.sha256(password)), c = (cansudo and true) or false}
    u.psave()
    return nuid
  end

  function u.del(uid)
    checkArg(1, uid, "number")
    if u.uid()  ~= 0 then
      return nil, "only root can do that"
    end
    if not u.passwd[uid] then
      return nil, "no such user"
    end
    u.passwd[uid] = nil
    u.psave()
    return true
  end

  -- run `func` as another user. Somewhat hacky.
  function u.sudo(func, uid, password)
    checkArg(1, func, "function")
    checkArg(2, uid, "number")
    checkArg(3, password, "string")
    if not u.passwd[u.uid()].c then
      return nil, "user is not allowed to sudo"
    end
    if hex(u.sha.sha256(password)) == u.passwd[u.uid()].p then
      local uuid = u.uid
      function u.uid()
        return uid
      end
      local s, r = pcall(func)
      u.uid = uuid
      return true, s, r
    end
    return nil, "permission denied"
  end

  kernel.users = u
end


-- kernel modules-ish --

do
  kernel.logger.log("initializing kernel module service")
  local m = {}
  local l = {}
  kernel.modules = l
  setmetatable(kernel, {__index = l})

  function m.load(mod)
    checkArg(1, mod, "string")
    if kernel.users.uid() ~= 0 then
      return nil, "permission denied"
    end
    local handle, err = kernel.filesystem.open("/lib/modules/" .. mod .. ".lua", "r")
    if not handle then
      return nil, err
    end
    local read = handle:read("*a")
    handle:close()
    local ok, err = load(read, "=" .. mod, "bt", _G)
    if not ok then
      return nil, err
    end
    l[mod] = ok()
    return true
  end

  function m.unload(mod)
    checkArg(1, mod, "string")
    if kernel.users.uid() ~= 0 then
      return nil, "permission denied"
    end
    l[mod] = nil
    return true
  end

  kernel.module = m
end


-- filesystem management --

do
  local fs = {}
--local log = component.sandbox.log
  local mounts = {}

  local protected = {
    "/boot",
    "/sbin",
    "/initramfs.bin"
  }

  local function split(path)
    local segments = {}
--  log("split " .. path)
    for seg in path:gmatch("[^/]+") do
      if seg == ".." then
        table.remove(segments, #segments)
      else
        table.insert(segments, seg)
      end
    end
    return segments
  end

  function fs.name(path)
    checkArg(1, path, "string")
    local s = split(path)
    return s[#s] or "/"
  end

  function fs.path(path)
    checkArg(1, path, "string")
    local s = split(path)
    return fs.canonical(table.concat(s, "/", 1, #s - 1))
  end

  local function resolve(path, noexist)
--  log("resolve " .. path)
    if path == "." then path = os.getenv("PWD") or "/" end
    if path:sub(1,1) ~= "/" then path = (os.getenv("PWD") or "/") .. path end
    local s = split(path)
    for i=#s, 1, -1 do
      local cur = "/" .. table.concat(s, "/", 1, i)
      local try = "/" .. table.concat(s, "/", i + 1)
      if mounts[cur] and (mounts[cur].exists(try) or noexist) then
        --component.sandbox.log("found", try, "on mount", cur, mounts[cur].address)
        return mounts[cur], try
      end
    end
    if mounts[path] then
      return mounts[path], "/"
    end
    if mounts["/"].exists(path) or noexist then
      return mounts["/"], path
    end
--  log("no such file or directory")
    return nil, path .. ": no such file or directory"
  end

  local basic =  {"makeDirectory", "exists", "isDirectory", "lastModified", "remove", "size", "spaceUsed", "spaceTotal", "isReadOnly", "getLabel"}
  for k, v in pairs(basic) do
    fs[v] = function(path)
      checkArg(1, path, "string", "nil")
--    log("called basic function " .. v .. " with argument " .. tostring(path))
      local mt, p = resolve(path, v == "makeDirectory")
      if path and not mt then
        return nil, p
      end
--    log("resolved to " .. mt.address .. ", path " .. p)
      return mt[v](p)
    end
  end

  function fs.list(path)
    checkArg(1, path, "string")
    local mt, p = resolve(path)
    if not mt then
      return nil, p
    end
    local files = mt.list(p or "/")
    local i = 0
    return setmetatable(files, {__call = function() i=i+1 return files[i] or nil end})
  end

  local function fread(self, amount)
    checkArg(1, amount, "number", "string")
    if amount == math.huge or amount == "*a" then
      local r = ""
      repeat
        local d = self.fs.read(self.handle, math.huge)
        r = r .. (d or "")
      until not d
      return r
    end
    return self.fs.read(self.handle, amount)
  end

  local function fwrite(self, data)
    checkArg(1, data, "string")
    return self.fs.write(self.handle, data)
  end

  local function fseek(self, whence, offset)
    checkArg(1, whence, "string")
    checkArg(2, offset, "number", "nil")
    offset = offset or 0
    return self.fs.seek(self.handle, whence, offset)
  end

  local open = {}

  local function fclose(self)
    open[self.handle] = nil
    return self.fs.close(self.handle)
  end

  function fs.open(path, mode)
    checkArg(1, path, "string")
    checkArg(2, mode, "string", "nil")
    local m = mode or "r"
    mode = {}
    for c in m:gmatch(".") do
      mode[c] = true
    end
    local node, rpath = resolve(path, true)
    if not node then
      return nil, rpath
    end

    local handle = node.open(rpath, m)
    if handle then
      local ret = {
        fs = node,
        handle = handle,
        seek = fseek,
        close = fclose
      }
      open[handle] = ret
      if mode.r then
        ret.read = fread
      end
      if mode.w or mode.a then
        ret.write = fwrite
      end
      return ret
    else
      return nil, path .. ": no such file or directory"
    end
  end

  function fs.closeAll()
    for _, h in pairs(open) do
      h:close()
    end
  end

  function fs.copy(from, to)
    checkArg(1, from, "string")
    checkArg(2, to, "string")
    local fhdl, ferr = fs.open(from, "r")
    if not fhdl then
      return nil, ferr
    end
    local thdl, terr = fs.open(to, "w")
    if not thdl then
      return nil, terr
    end
    thdl:write(fhdl:read("*a"))
    thdl:close()
    fhdl:close()
    return true
  end

  function fs.rename(from, to)
    checkArg(1, from, "string")
    checkArg(2, to, "string")
    local ok, err = fs.copy(from, to)
    if not ok then
      return nil, err
    end
    local ok, err = fs.remove(from)
    if not ok then
      return nil, err
    end
    return true
  end

  function fs.canonical(path)
    checkArg(1, path, "string")
    if path == "." then
      path = os.getenv("PWD") or "/"
    elseif path:sub(1,1) ~= "/" then
      path = (os.getenv("PWD") or "/") .. "/" .. path
    end
    local p = "/" .. table.concat(split(path), "/")
    --component.sandbox.log(p)
    return p
  end

  function fs.concat(path1, path2, ...)
    checkArg(1, path1, "string")
    checkArg(2, path2, "string")
    local args = {...}
    for i=1, #args, 1 do
      checkArg(i + 2, args[i], "string")
    end
    local path = table.concat({path1, path2, ...}, "/")
    return fs.canonical(path)
  end

  local function rowrap(prx)
    local function t()
      return true
    end
    local function roerr()
      error(prx.address:sub(1,8) .. ": filesystem is read-only")
    end
    local mt = {
      __index = prx,
      __newindex = function()error("table is read-only")end,
      __ro = true
    }
    return setmetatable({
      isReadOnly = t,
      write = roerr,
      makeDirectory = roerr,
      remove = roerr,
      setLabel = roerr,
      open = function(f, m)
        m = m or "r"
        if m:find("[wa]") then
          return nil, "filesystem is read-only"
        end
        return prx.open(f, m)
      end
    }, mt)
  end

  local function proxywrap(prx)
    local mt = {
      __index = prx,
      __newindex = function()error("table is read-only")end,
      __ro = true
    }
    return setmetatable({}, mt)
  end

  function fs.mount(fsp, path, ro)
    checkArg(1, fsp, "string", "table")
    checkArg(2, path, "string")
    checkArg(2, ro, "boolean", "nil")
    --path = fs.canonical(path)
    if path ~= "/" and not fs.exists(path) then fs.makeDirectory(path) end
    if type(fsp) == "string" then
      fsp = component.proxy(fsp)
    end
    if mounts[path] == fsp then
      return true
    end
    if ro then
      mounts[path] = rowrap(fsp)
    else
      mounts[path] = proxywrap(fsp)
    end
    return true
  end

  function fs.mounts()
    local m = {}
    for path, proxy in pairs(mounts) do
      m[path] = proxy.address
    end
    return m
  end

  function fs.umount(path)
    checkArg(1, path, "string")
    if not mounts[path] then
      return nil, "no filesystem mounted at " .. path
    end
    if path == "/" then
      return nil, "cannot unmount /"
    end
    mounts[path] = nil
    return true
  end

  function fs.get(path)
    checkArg(1, path, "string")
    return resolve(path)
  end

  fs.mount(computer.getBootAddress(), "/")
  fs.mount(computer.tmpAddress(), "/tmp")

  kernel.filesystem = fs
end


-- computer.shutdown stuff --

do
  --local log = component.sandbox.log
  local shutdown = computer.shutdown
  local closeAll = kernel.filesystem.closeAll
  kernel.filesystem.closeAll = nil
  function computer.shutdown(reboot)
    checkArg(1, reboot, "boolean", "nil")
    local running = kernel.process.processes()
    computer.pushSignal("shutdown")
    kernel.logger.log("shutting down")
    coroutine.yield()
    kernel.logger.log("close all file handles")
    closeAll()
    -- clear all GPUs
    kernel.logger.log("clear all the screens")
    for addr, _ in component.list("gpu") do
      local w, h = component.invoke(addr, "getResolution")
      component.invoke(addr, "fill", 1, 1, w, h, " ")
    end
    kernel.logger.log("shut down")
    shutdown(reboot)
  end
end


-- run levels --

do
  local rl = {}
  rl.levels = {
    [0] = {
      booted = false,
      init = false,
      services = false,
      multiuser = false
    },
    [1] = {
      booted = true,
      init = true,
      services = false,
      multiuser = false
    },
    [2] = {
      booted = true,
      init = true,
      multiuser = false,
      services = true
    },
    [3] = {
      booted = true,
      init = true,
      multiuser = true,
      services = true
    }
  }
  local level = 0
  function rl.setrunlevel(n)
    if not rl.levels[n] or n > flags.runlevel then
      return nil, "invalid runlevel"
    end
    if kernel.users.uid() ~= 0 then
      return nil, "permission denied"
    end
    level = n
    return true
  end

  function rl.getlevel()
    return level
  end

  kernel.runlevel = rl
end


-- it's finally time to rewrite the scheduler and related things. here we go!! --

do
  kernel.logger.log("initializing 'process' type")

  local proc_type = {} -- the base "process" template

  function proc_type:resume(...) -- resumes every thread in the process, in order
    if self.stopped then return nil end
    local timeout = math.huge
    for n, thread in ipairs(self.threads) do
      local ok, ret = coroutine.resume(thread, ...)
      if not ok and ret then
        self.threads[n] = nil
        self.handlers.default(string.format("process %d: error in thread %d: %s", self.pid, n, ret or "not specified"))
      end
      if type(ret) == "number" then
        local newTimeout = computer.uptime() + ret
        if newTimeout < timeout then
          timeout = newTimeout
        end
      end
    end
    if #self.threads == 0 then
      self.dead = true
    end
    return timeout
  end

  function proc_type:addthread(func) -- add a "child" thread (coroutine)
    local new = coroutine.create(function()
      assert(xpcall(func, debug.traceback)) -- this gives us a stack traceback if the thread errors while still propagating the error, and exits cleanly if it doesn't.
    end)
    table.insert(self.threads, new)
    return #self.threads
  end

  function proc_type:delthread(n)
    self.threads[n] = nil
    return true
  end

  function proc_type:kill()
    self.dead = true
  end

  function proc_type:stop()
    self.stopped = true
  end

  function proc_type:continue()
    self.stopped = false
  end

  function proc_type:interrupt()
    self.handlers.interrupt("interrupted")
  end

  function proc_type:terminate()
    self.handlers.terminate("terminated")
  end

  function proc_type:usr1()
    self.handlers.usr1("user signal 1")
  end

  function proc_type:usr2()
    self.handlers.usr2("EXECUTE ORDER 66")
  end

  function proc_type.new(name, handlers, env)
    local new = {
      name = name,
      handlers = handlers or {default = kernel.logger.panic},
      env = env or {},
      threads = {},
      pid = 0,
      dead = false,
      owner = kernel.users.uid(),
      users = {kernel.users.uid()},
      stopped = false,
      started = computer.uptime(),
      io = {[0] = {}, [1] = {}, [2] = {}},
      signals = {},
      deadline = 0
    }
    new.env.PWD = new.env.PWD or "/"
    new.env.UID = new.owner
    handlers.default = handlers.default or kernel.logger.panic
    setmetatable(new.handlers, {__index = function() return new.handlers.default end})
    local ts = tostring(new):gsub("table", "process")
    return setmetatable(new, {__type = "process", __tostring = function() return ts end, __index = proc_type})
  end

  ------------------------------------------------------------------------------------------

  kernel.logger.log("initializing scheduler")
  local process, processes, lastpid, current = {}, {}, 0, 0

  function process.spawn(func, name, handlers, env)
    checkArg(1, func, "function")
    checkArg(2, name, "string")
    checkArg(3, handlers, "function", "table", "nil")
    checkArg(4, env, "table", "nil")
    if type(handlers) == "function" then handlers = {default = handlers} end
    handlers = handlers or {default = kernel.logger.panic}
    env = env or kernel.table_copy((processes[current] or {env = {}}).env)
    local new = proc_type.new(name, handlers, env)
    lastpid = lastpid + 1
    new.pid = lastpid
    new.parent = current
    local dummy = {io = {[0] = {}, [1] = {}, [2] = {}}}
    new.io[0] = (processes[current] or dummy).io[0]
    new.io[1] = (processes[current] or dummy).io[1]
    new.io[2] = (processes[current] or dummy).io[2]
    new:addthread(func)
    processes[lastpid] = new
    coroutine.yield(0)
    return lastpid
  end

  -- os.setenv and os.getenv are defined in init now rather than here

  -- (re)define kernel.users stuff to be thread-local. Not done in module/users.lua as it requires low-level access.
  local ulogin, ulogout, uuid = kernel.users.login, kernel.users.logout, kernel.users.uid
  function kernel.users.login(uid, password)
    checkArg(1, uid, "number")
    checkArg(2, password, "string")
    local ok, err = kernel.users.authenticate(uid, password)
    if not ok then
      return nil, err
    end
    if processes[current] then
      table.insert(processes[current].users, 1, uid)
      return true
    end
    return ulogin(uid, password)
  end

  function kernel.users.logout()
    if processes[current] then
      table.remove(processes[current].users, 1)
      return true
    end
    return false -- kernel is always root
  end

  function kernel.users.uid()
    if processes[current] then
      return processes[current].users[1]
    else
      return 0 -- again, kernel is always root
    end
  end

  function process.processes()
    local p = {}
    for pid, _ in pairs(processes) do
      p[#p+1] = pid
    end
    return p
  end

  function process.info(pid)
    checkArg(1, pid, "number", "nil")
    pid = pid or current
    local p = processes[pid]
    if not p then
      return nil, "no such process: " .. pid
    end
    local info = {
      name = p.name,
      owner = p.owner,
      started = p.started,
      threads = #p.threads,
      stopped = p.stopped
    }
    if pid == current then
      local data = {
        env = p.env,
        ipc = p.ipc,
        handlers = p.handlers,
        io = p.io,
        threads = p.threads
      }
      info.data = data
    end
    return info
  end

  process.signals = {
    [2]         = "interrupt",
    [9]         = "kill",
    [15]        = "terminate",
    [18]        = "continue",
    [19]        = "stop",
    [65]        = "usr1",
    [66]        = "usr2",
    interrupt   = 2,
    kill        = 9,
    terminate   = 15,
    continue    = 18,
    stop        = 19,
    usr1        = 65,
    usr2        = 66
  }

  function process.signal(pid, sig)
    checkArg(1, pid, "number")
    checkArg(2, sig, "number", "string")
    if not processes[pid] then
      return nil, "no such process"
    end
    if not process.signals[sig] then
      return nil, "unrecognized signal"
    end
    if type(sig) == "number" then sig = process.signals[sig] end
    processes[pid][sig](processes[pid])
    return true
  end

  function process.ipc(pid, ...)
    checkArg(1, pid, "number")
    if not processes[pid] then
      return nil, "no such process"
    end
    local sig = table.pack("ipc", pid, ...)
    table.insert(processes[pid].signals, sig)
    return true
  end

  function process.current()
    return current
  end

  function process.detach()
    processes[cur].parent = 0
  end

  function process.orphan(pid)
    checkArg(1, pid, "number")
    if not processes[pid] then
      return nil, "no such thread"
    end
    if processes[pid].parent ~= current then
      return nil, "specified process is not a child of the current process"
    end
    processes[pid].parent = 0
    return true
  end

  function process.start()
    process.start = nil
    while #processes > 0 do
      local signal = {}
      local timeout = math.huge
      local uptime = computer.uptime()
      for pid, proc in pairs(processes) do
        if proc.deadline < uptime then
          timeout = uptime - proc.deadline
          if timeout <= 0 then
            timeout = 0
            break
          end
        end
      end
      signal = table.pack(computer.pullSignal(timeout))
      local run = {}
      for pid, proc in pairs(processes) do
        if (proc.deadline < uptime or #proc.signals > 0 or signal.n > 0) and not proc.stopped then
          run[#run + 1] = proc
          if #proc.signals > 0 and signal.n > 0 then
            table.insert(proc.signals, signal)
          end
        end
      end

      local start = computer.uptime()
      for _, proc in ipairs(run) do
        current = proc.pid
        local timeout = proc:resume(table.unpack((#proc.signals > 0 and table.remove(proc.signals, 1)) or signal))
        if timeout then
          proc.deadline = computer.uptime() + timeout
        end
        if computer.uptime() - start > 5 then
          goto cleanup
        end
      end

      ::cleanup::
      for pid, proc in pairs(processes) do
        if proc.dead then
          processes[pid] = nil
        end
      end
    end
  end

  kernel.process = process
end


-- userspace sandbox and some security features --

kernel.logger.log("wrapping setmetatable, getmetatable for security, type for reasons")

local smt, gmt, typ, err = setmetatable, getmetatable, type, error

function _G.error(e, l)
  local pref = "/"
  if kernel.filesystem.get("/").isReadOnly() then
    pref = "/tmp/"
  end
  local handle = kernel.filesystem.open(pref .. "err_" .. os.date():gsub("[ :\\/]", "_"), "a")
  handle:write(debug.traceback(e).."\n")
  --kernel.logger.log(debug.traceback(e))
  handle:close()
  err(e, l)
end

function _G.setmetatable(tbl, mt)
  checkArg(1, tbl, "table")
  checkArg(2, mt, "table")
  local _mt = gmt(tbl)
  if _mt and _mt.__ro then
    error("table is read-only")
  end
  return smt(tbl, mt)
end

function _G.getmetatable(tbl)
  checkArg(1, tbl, "table")
  local mt = gmt(tbl)
  local _mt = {
    __index = mt,
    __newindex = function()error("metatable is read-only")end,
    __ro = true
  }
  if mt and mt.__ro then
    return smt({}, _mt)
  else
    return mt
  end
end

function _G.type(obj)
  local t = typ(obj)
  if t == "table" and getmetatable(obj) and getmetatable(obj).__type then
    return getmetatable(obj).__type
  end
  return t
end

kernel.logger.log("setting up userspace sandbox")

local sandbox = {}

-- it is now time for an actually working sandbox!
function kernel.table_copy(t)
  local seen = {}
  local function copy(tbl)
    local ret = {}
    for k, v in pairs(tbl) do
      if type(v) == "table" and not seen[v] then
        seen[v] = true
        ret[k] = copy(v)
      else
        ret[k] = v
      end
    end
    return ret
  end
  return copy(t)
end

sandbox = kernel.table_copy(_G)
sandbox._G = sandbox
sandbox.computer.pullSignal = coroutine.yield
sandbox.kernel.users = kernel.users -- this is a hack fix for a weird annoying bug


-- basic loadfile function --

local function loadfile(file, mode, env)
  checkArg(1, file, "string")
  checkArg(2, mode, "string", "nil")
  checkArg(3, env, "table", "nil")
  mode = mode or "bt"
  env = env or sandbox
  local handle, err = kernel.filesystem.open(file, "r")
  if not handle then
    return nil, err
  end
  --kernel.logger.log("loadfile " .. file)
  local data = handle:read("*a")
  handle:close()
  if data:sub(1,1) == "#" then -- crude shebang detection
    data = "--" .. data
  end
  return load(data, "=" .. file, mode, env)
end

sandbox.loadfile = loadfile


kernel.logger.log("loading init from " .. flags.init)

local ok, err = loadfile(flags.init, "bt", sandbox)
if not ok then
  kernel.logger.panic(err)
end

kernel.process.spawn(function()return ok(flags.runlevel or 3) end, flags.init, {default = kernel.logger.panic})
kernel.runlevel.setrunlevel(1)
kernel.process.start()
